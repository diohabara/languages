# dcc

This is a compiler of C language

This compiler is implemeted following [this site's instruction](https://www.sigbus.info/compilerbook)

## Work log

### Day1

```shell
sudo apt update
sudo apt install -y gcc make git binutils libc6-dev
```

をした

- `x86-64`という命令セットを使う
- これから使うCコンパイラの出力はアセンブリ
- <https://godbolt.org/>というサイトがアセンブリをリアルタイムに出力してくれる
- `30 + (4 - 2) * -5`をコンパイルできることが目標
- まずは整数1つだけからなる言語を作る
- `dcc`というディレクトリを作成し,その中にコンパイラ`dcc`を作った

`dcc`によるコンパイルは以下のようにする

```shell
gcc -o dcc dcc.c # 自作コンパイラをgccでコンパイル
./dcc 123 > tmp.s # 123を引数にして出力をアセンブリファイルに入れる
```

これによって作成されたアセンブリファイル`tmp.s`をアセンブラに渡すと実行ファイルを作成できる

```shell
gcc -o tmp tmp.s # アセンブリをアセンブラでコンパイル
./tmp # アセンブルした結果の実行ファイルを実行
echo $? # 出力を表示
```

- 自動テストを作成する
- `test.sh`というテスト用のシェルスクリプトを作る

```shell
chmod a+x test.sh
```

というコマンドでシェルスクリプトを実行可能にする

そして次のコマンドを実行してエラーが起きないかを確認する

```shell
$ ./test.sh
...
OK
```

エラーが起きたら`OK`は表示されない.代わりにエラー文が表示される

テストスクリプトをデバッグしたいときは以下のコマンドを実行する.実行すると実行のトレースを表示してくれる

```shell
bash -x test.sh
```

- `make`でビルドができるようにする
  - `make`で`dcc`が作成される
  - `make test`でテストを実行する
  - `make clean`で一時ファイルを消す

- `git`でバージョン管理する
- これは大丈夫かな

- 簡単な電子計算機を作る
- この定義は次の通り
  - 最初に数字が1つ以上
  - 0個以上の項が続く
  - 項とは`+`or`-`の後に数字が来る
- できたが,トークナイザが実装されていないのでコンパイル時に空白文字を無視できない
  - 実装する

わからない関数は調べた

- `va_list`
- `va_start`
- `vprintf`
- `strtol`

## Day2

- エラーに関する関数を実装したところせぐふぉが発生

```shell
ulimit -c unlimited
```

というコマンドの後にせぐふぉが出てくるように実行をする.そのときに`core`なんたらというファイルが生成される.これがせぐふぉが起きたときの履歴を記したファイルなので以下のコマンドを実行する

```shell
gdb dcc core
```

例えば今回は次のようなエラー文が出てきた

```shell
GNU gdb (Ubuntu 8.1-0ubuntu3.1) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from dcc...done.
[New LWP 15136]
Core was generated by `./dcc 1*1'.
Program terminated with signal SIGSEGV, Segmentation fault.
---Type <return> to continue, or q <return> to quit---
#0  0x0000000000400ff2 in tokenize (p=0x7ffe8fa2bf2c "*1") at dcc.c:129
129             error_at(token->str, "cannot be tokenized");
```

129行目でせぐふぉが発生している?

`tokenize`関数の内部で,`tokenize`できない関数が出てきた時のエラー文でせぐふぉが出てくるらしい

直すのは引数の部分で,`cur->str`としていた部分を`p`とするだけだった

## Day3

- 構文解析をする
- 抽象構文木の話がされている
- 生成規則について学ぶ
- BNFと拡張BNFとについて

## Day4

- スタックマシンについて実装完了

## Day5

- めっちゃ久々にやる(@2020/03/10)
- step5をやる
  - 終わった．読むだけ
- step6をやる
  - 単項演算子だった．ここまで前もやったな．
- step7をやる
  - 比較演算子っぽい．
  - 比較演算子は作り終わった．
  - 文法の通りに実装すれば良いだけだった(の割に時間がかかった…)
  - 次は分割コンパイルとリンク
    - 流石にコードが大きくなっていたのでありがたい．
- step8
  - ファイルの分割とMakefileの変更をするっぽい
  - 変更をしていく

## Day6

- step8
  - ファイルの分割をする
    - した
  - 次はMakefileを作る
    - 書き換えた
  - 宣言だけして，定義をしていなかったのでその部分を直した
- step9
  - ローカル変数を実装する
  - たぶん実装できた
  - 新しい文法まで出来たと思う
  - 任意のアドレスから値をロードするらしい
  - 次に式を左辺地として評価する関数を追加し，これによって右辺地に右辺値を代入することはなくなるっぽい
  - `0; ^ cannot be tokenized`と出てくる
  - どこかでtokenize出来ていないようだが，どこが原因なのか…
  - 直った．`strchr`に`=;`を含めれば良いだけだった
- step10
  - 複数文字ローカル変数(前回は1文字)の実装をする
    - テストをするとstep9のassignmentが上手く行ってないので直す
    - `segmentation fault`が消えない

```sh
./test.sh: line 2: 30572 Segmentation fault      (core dumped) ./dcc "$input" > tmp.s
/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o: In function `_start':
(.text+0x20): undefined reference to `main'
collect2: error: ld returned 1 exit status
./test.sh: line 8: ./tmp: No such file or directory
a = 3; => 3 expected, but got 127
Makefile:11: recipe for target 'test' failed
make: *** [test] Error 1
```

- 無限にこのエラー文が出てくる
- 諸々見直してみた．ただバグは直っていない．
- 何が原因なのか分からないのでとりあえず，1つずつファイルを見ていく．
  - `codegen.c`
    - 問題なさそうだった．(ASSIGN周辺を見た)
  - `container.c`
  - `parse.c`
  - `main.c`の順で見ていこうと思う．
- 思うに`segmentation fault`になっていることから，原因はアセンブリにあるのでは？という推測の元．
- 上手く行かないので，とりあえずstep10に進んで，そのときに直す(同じローカル変数に関するテーマなので)
- step10: 複数文字のローカル変数
  - 何故かわからないけど，1文字のローカル変数は出来た．
  - しかし，複数文字のローカル変数が出来ない…
  - 1文字のローカル変数の理由は分かった．同じ変数を操作する関数は同じファイルに書く必要があるっぽい．というか定義が同じでないといけないっぽい．`extern`を使うべき．
- 出来た．
  - 結果的に`error_at`は使わないことになった．
  - 複数文字のローカル変数が出来たのは結構嬉しい．次だ次
- step11: return文
