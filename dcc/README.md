# dcc

This is a compiler of C language

This compiler is implemeted following [this site's instruction](https://www.sigbus.info/compilerbook)

## EBNF

```ebnf
program    = stmt* ;
stmt       = expr, ";"
           | "{", stmt*, "}"
           | "if", "(", expr, ")", stmt, ("else", stmt)?
           | "while", "(", expr, ")", stmt
           | "for", "(", expr, ?, ";", expr?, ";", expr?, ")", stmt
           | "return", expr, ";" ;
expr       = assign ;
assign     = equality, ("=", assign)? ;
equality   = relational, ("==", relational | "!=", relational)* ;
relational = add, ("<", add | "<=", add | ">", add | ">=", add)* ;
add        = mul, ("+", mul | "-", mul)* ;
mul        = unary, ("*", unary | "/", unary)* ;
unary      = ("+" | "-")?, primary ;
primary    = num
           | ident, ("(", ")")?
           | "(", expr, ")" ;
```

## Work log

### Day1

```shell
sudo apt update
sudo apt install -y gcc make git binutils libc6-dev
```

をした

- `x86-64`という命令セットを使う
- これから使うCコンパイラの出力はアセンブリ
- <https://godbolt.org/>というサイトがアセンブリをリアルタイムに出力してくれる
- `30 + (4 - 2) * -5`をコンパイルできることが目標
- まずは整数1つだけからなる言語を作る
- `dcc`というディレクトリを作成し,その中にコンパイラ`dcc`を作った

`dcc`によるコンパイルは以下のようにする

```shell
gcc -o dcc dcc.c # 自作コンパイラをgccでコンパイル
./dcc 123 > tmp.s # 123を引数にして出力をアセンブリファイルに入れる
```

これによって作成されたアセンブリファイル`tmp.s`をアセンブラに渡すと実行ファイルを作成できる

```shell
gcc -o tmp tmp.s # アセンブリをアセンブラでコンパイル
./tmp # アセンブルした結果の実行ファイルを実行
echo $? # 出力を表示
```

- 自動テストを作成する
- `test.sh`というテスト用のシェルスクリプトを作る

```shell
chmod a+x test.sh
```

というコマンドでシェルスクリプトを実行可能にする

そして次のコマンドを実行してエラーが起きないかを確認する

```shell
$ ./test.sh
...
OK
```

エラーが起きたら`OK`は表示されない.代わりにエラー文が表示される

テストスクリプトをデバッグしたいときは以下のコマンドを実行する.実行すると実行のトレースを表示してくれる

```shell
bash -x test.sh
```

- `make`でビルドができるようにする
  - `make`で`dcc`が作成される
  - `make test`でテストを実行する
  - `make clean`で一時ファイルを消す

- `git`でバージョン管理する
- これは大丈夫かな

- 簡単な電子計算機を作る
- この定義は次の通り
  - 最初に数字が1つ以上
  - 0個以上の項が続く
  - 項とは`+`or`-`の後に数字が来る
- できたが,トークナイザが実装されていないのでコンパイル時に空白文字を無視できない
  - 実装する

わからない関数は調べた

- `va_list`
- `va_start`
- `vprintf`
- `strtol`

### Day2

- エラーに関する関数を実装したところせぐふぉが発生

```shell
ulimit -c unlimited
```

というコマンドの後にせぐふぉが出てくるように実行をする.そのときに`core`なんたらというファイルが生成される.これがせぐふぉが起きたときの履歴を記したファイルなので以下のコマンドを実行する

```shell
gdb dcc core
```

例えば今回は次のようなエラー文が出てきた

```shell
GNU gdb (Ubuntu 8.1-0ubuntu3.1) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from dcc...done.
[New LWP 15136]
Core was generated by `./dcc 1*1'.
Program terminated with signal SIGSEGV, Segmentation fault.
---Type <return> to continue, or q <return> to quit---
#0  0x0000000000400ff2 in tokenize (p=0x7ffe8fa2bf2c "*1") at dcc.c:129
129             error_at(token->str, "cannot be tokenized");
```

129行目でせぐふぉが発生している?

`tokenize`関数の内部で,`tokenize`できない関数が出てきた時のエラー文でせぐふぉが出てくるらしい

直すのは引数の部分で,`cur->str`としていた部分を`p`とするだけだった

### Day3

- 構文解析をする
- 抽象構文木の話がされている
- 生成規則について学ぶ
- BNFと拡張BNFとについて

### Day4

- スタックマシンについて実装完了

### Day5

- めっちゃ久々にやる(@2020/03/10)
- step5をやる
  - 終わった．読むだけ
- step6をやる
  - 単項演算子だった．ここまで前もやったな．
- step7をやる
  - 比較演算子っぽい．
  - 比較演算子は作り終わった．
  - 文法の通りに実装すれば良いだけだった(の割に時間がかかった…)
  - 次は分割コンパイルとリンク
    - 流石にコードが大きくなっていたのでありがたい．
- step8
  - ファイルの分割とMakefileの変更をするっぽい
  - 変更をしていく

### Day6

- step8
  - ファイルの分割をする
    - した
  - 次はMakefileを作る
    - 書き換えた
  - 宣言だけして，定義をしていなかったのでその部分を直した
- step9
  - ローカル変数を実装する
  - たぶん実装できた
  - 新しい文法まで出来たと思う
  - 任意のアドレスから値をロードするらしい
  - 次に式を左辺地として評価する関数を追加し，これによって右辺地に右辺値を代入することはなくなるっぽい
  - `0; ^ cannot be tokenized`と出てくる
  - どこかでtokenize出来ていないようだが，どこが原因なのか…
  - 直った．`strchr`に`=;`を含めれば良いだけだった
- step10
  - 複数文字ローカル変数(前回は1文字)の実装をする
    - テストをするとstep9のassignmentが上手く行ってないので直す
    - `segmentation fault`が消えない

```sh
./test.sh: line 2: 30572 Segmentation fault      (core dumped) ./dcc "$input" > tmp.s
/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o: In function `_start':
(.text+0x20): undefined reference to `main'
collect2: error: ld returned 1 exit status
./test.sh: line 8: ./tmp: No such file or directory
a = 3; => 3 expected, but got 127
Makefile:11: recipe for target 'test' failed
make: *** [test] Error 1
```

- 無限にこのエラー文が出てくる
- 諸々見直してみた．ただバグは直っていない．
- 何が原因なのか分からないのでとりあえず，1つずつファイルを見ていく．
  - `codegen.c`
    - 問題なさそうだった．(ASSIGN周辺を見た)
  - `container.c`
  - `parse.c`
  - `main.c`の順で見ていこうと思う．
- 思うに`segmentation fault`になっていることから，原因はアセンブリにあるのでは？という推測の元．
- 上手く行かないので，とりあえずstep10に進んで，そのときに直す(同じローカル変数に関するテーマなので)
- step10: 複数文字のローカル変数
  - 何故かわからないけど，1文字のローカル変数は出来た．
  - しかし，複数文字のローカル変数が出来ない…
  - 1文字のローカル変数の理由は分かった．同じ変数を操作する関数は同じファイルに書く必要があるっぽい．というか定義が同じでないといけないっぽい．`extern`を使うべき．
- 出来た．
  - 結果的に`error_at`は使わないことになった．
  - 複数文字のローカル変数が出来たのは結構嬉しい．次だ次
- step11: return文

### Day7

- step11: return文
  - 実装完了
- step12: 制御構文を足す
  - `if`, `while`, `for`を新たに実装するっぽい

### Day8

- step12: 制御構文を足す
  - 続きをする
  - `if else`文の実装が結構難しい
    - [このサイト](https://godbolt.org/)でアセンブリを吐かせて見れば良いのでは？
    - 上手く行かないんだけど^^;
  - `tokenize`関数で条件分岐して，そこで`IF`か`IFELSE`かを分ければいいのではないかという考えに至った
  - なんか上手く行かない
  - 書いているコード自体は間違っていない気がする．参照しているアセンブリが間違っている？
    - アセンブリを見てみる

### Day9

- step12: 制御構文を足す
- 結局昨日も制御構文が追加できなかったので，これを行う
  - `if`文の実装には成功した
  - `ifelse`文の実装が失敗している
  - `else`の部分が上手くパース出来ていない？

```console
tmp.s: Assembler messages:
tmp.s:13: Error: unknown pseudo-op: `.lelsexxx'
tmp.s:15: Error: unknown pseudo-op: `.lendxxx'
if (1) 1; else 0; => 1
tmp.s: Assembler messages:
tmp.s:13: Error: unknown pseudo-op: `.lelsexxx'
tmp.s:15: Error: unknown pseudo-op: `.lendxxx'
if (0) 1; else 0; => 0 expected, but got 1
Makefile:11: recipe for target 'test' failed
make: *** [test] Error 1
```

- というエラー文が出てくる
- 見た感じ，サイトの方のアセンブリが間違えている？？？
- ということでアセンブリを見直す
- ジャンプ元は`.LelseXXX`で良いが，ジャンプ後のラベルは`.LelseXXX:`と書く必要がある．
- 直った:smile:
- `while`文までは上手く行った:smile:
- 次は`for`なんだけど上手く行かない…なぜ

```console
for statement
./test.sh: line 2: 23921 Segmentation fault      (core dumped) ./dcc "$input" > tmp.s
/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o: In function `_start':
(.text+0x20): undefined reference to `main'
collect2: error: ld returned 1 exit status
./test.sh: line 8: ./tmp: No such file or directory
a = 0; for (a = 0; a < 5; a = a + 1) 1; return a; => 5 expected, but got 127
Makefile:11: recipe for target 'test' failed
make: *** [test] Error 1
```

- 上のようなエラー文が出てくる．`for (init; cond; step) then`の`then`が式になっている？
- `try 5 "b = 0; for (a = 0; a < 5; a = a + 1) b = b + 1; b;"`
- このようなテストの結果が`1`になるので，ループされていないっぽい．
- `je`と`jmp`を間違えていた…
- `for`文の実装終わった:smile:
- step13: ブロック
  - 次は`{}`の実装をするっぽい
  - 構文的には関数の`{}`も`if`や`while`で使われるものと同じらしい
  - `ND_BLOCK`を追加する
  - ブロックに含まれる式を持つvectorを追加する必要がある
  - ノードが`ND_BLOCK`のとき，そのノードに含まれるステートメントのコードを順番に生成するようにする
  - 1つ1つのステートメントが1つの値をスタックに残すので，それをポップしないようにする

### Day10

- step13: ブロック
  - 引き続きこれをやっていく．
  - まずはvectorの実装．
  - vectorの実装を行ったは出来たはず．
  - `data:ポインタの入る配列`, `capacity:vectorの大きさで足りなくなると倍増する`, `len:現在入っている要素の数でこれから入れる要素の位置`を持っているデータ構造
  - `{`から`}`までの式を全てここに格納する．
  - パーサーの方は実装出来たはず．アセンブリを生成すれば良さそう．
  - と思ったが下記のようなエラーが出るので，パーサーが失敗していそう．
  -

  ```console
  step13: block statement
  ---
  ***
  } is expected, but got a
  ***
  /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o: In function `_start':
  (.text+0x20): undefined reference to `main'
  collect2: error: ld returned 1 exit status
  ./test.sh: line 8: ./tmp: No such file or directory
  a = 1; {a = 3;} a; => 1 expected, but got 127
  Makefile:11: recipe for target 'test' failed
  make: *** [test] Error 1
  ```

  - 直した…はず
  - 何かが直っていない．
  - 複文だけのプログラムで失敗するみたい．これをどうにかして直したい．
  - 直った！．原因は`calloc`でメモリを確保していなかったからでこれで想定していなかった領域を触っていたことっぽい．
